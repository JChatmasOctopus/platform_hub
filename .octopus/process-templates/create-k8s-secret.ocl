name = "Create Kubernetes Secret"
description = "A standardized deployment template for Kubernetes secrets. It includes steps to create and manage Secret objects, securely inject sensitive data into pods, and reference them from deployments, Helm charts, or raw manifests. Ideal for consistent, repeatable handling of credentials, connection strings, and API keys across clusters, environments, and tenants."
parameter "Parameter.Target.Tag" {
    display_settings = {
        Octopus.ControlType = "TargetTags"
    }
    help_text = ""
    label = "Kubernetes Target Tag"
}
parameter "Parameter.Secret.Username" {
    display_settings = {
        Octopus.ControlType = "Sensitive"
    }
    help_text = ""
    label = "Secret Username"
}
parameter "Parameter.Secret.Password" {
    display_settings = {
        Octopus.ControlType = "Sensitive"
    }
    help_text = ""
    label = "Secret Password"
}
parameter "Parameter.Kubernetes.Namespace" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = ""
    label = "Kubernetes Namespace"
}
parameter "Parameter.Kubernetes.Secret.Name" {
    display_settings = {
        Octopus.ControlType = "SingleLineText"
    }
    help_text = "Name of secret"
    label = "Kubernetes Secret Name"
}
step "create-secret" {
    name = "Create Secret"
    properties = {
        Octopus.Action.TargetRoles = "#{Parameter.Target.Tag}"
    }
    action {
        action_type = "Octopus.Script"
        properties = {
            Octopus.Action.RunOnServer = "false"
            Octopus.Action.Script.ScriptBody = <<-EOT
                # Fail fast
                $ErrorActionPreference = "Stop"
                # Inputs
                $username   = $OctopusParameters["Parameter.Secret.Username"]        # e.g. adamoctoclose
                $password   = $OctopusParameters["Parameter.Secret.Password"]        # classic PAT with read:packages
                $namespace  = $OctopusParameters["Parameter.Kubernetes.Namespace"]
                $secretName = $OctopusParameters["Parameter.Kubernetes.Secret.Name"]
                if ([string]::IsNullOrWhiteSpace($secretName)) { $secretName = "ghcr-pull-secret" }
                Write-Host ":dart: Namespace: $namespace"
                Write-Host ":closed_lock_with_key: Secret: $secretName"
                Write-Host ":bust_in_silhouette: GitHub: $username"
                if ($password -like "http*") {
                  throw ":x: Token looks like a URL. Provide a classic PAT with read:packages."
                }
                # 1) Namespace: create only if missing
                $ns = kubectl get ns $namespace --ignore-not-found -o name
                if ([string]::IsNullOrWhiteSpace($ns)) {
                  Write-Host ":file_folder: Creating namespace '$namespace'..."
                  kubectl create ns $namespace | Out-Null
                } else {
                  Write-Host ":white_check_mark: Namespace '$namespace' already exists."
                }
                # 2) Secret: delete if exists, then create (or just create if missing)
                $existing = kubectl -n $namespace get secret $secretName --ignore-not-found -o name
                if (-not [string]::IsNullOrWhiteSpace($existing)) {
                  Write-Host ":broom: Deleting existing secret '$secretName'..."
                  kubectl -n $namespace delete secret $secretName --ignore-not-found | Out-Null
                }
                Write-Host ":closed_lock_with_key: Creating secret '$secretName' for ghcr.io..."
                kubectl -n $namespace create secret docker-registry $secretName `
                  --docker-server=ghcr.io `
                  --docker-username=$username `
                  --docker-password=$password | Out-Null
                Write-Host ":white_check_mark: Done."
                EOT
            Octopus.Action.Script.ScriptSource = "Inline"
            Octopus.Action.Script.Syntax = "PowerShell"
            OctopusUseBundledTooling = "False"
        }
    }
}
